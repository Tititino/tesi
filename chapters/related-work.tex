\chapter{Related work}\label{chapter:related work}
Most bottom-up provers for classic linear logic use some combination of focusing and normalization to structure their proofs, with the notable exception of llprover \cite{llprover} not using normalization.	% credo
In this chapter we give a closer look to two such provers: the aforementioned llprover and APLL \cite{APLL}.
In particular we will talk about three main characteristics: normalization, how spitting is handled, and bounds for exponentials.

Obviously there are many other provers for linear logic, among all we cite: 
\begin{itemize}
	\item sympli \cite{sympli}, a top-down prover based on the inverse method proposed by K. Chaudhuri in \cite{inverse};
	\item linTAP \cite{linTAPwebsite, linTAP}, a tableau prover for MELL (the multiplicative and exponential fragment of linear logic).
\end{itemize}
Ultimately we chose to compare against the two provers above as they more or less implement the same algorithm as us.

\section{APLL}\label{sec:apll}
APLL is the underlying prover of click\&collect \cite{clickAndCollect}, an interactive tool for building linear logic proofs in sequent calculus.
It provides 4 different searches -- forward and backwards for classic and intuitionistic linear logic. 
We will focus on the backwards algorithm for classic linear logic.

The program is written in OCaML and implements a standard focused proof search on normalized formulae as seen in \cite{LiangMiller}.
Sequent splitting when encountering a tensor is done by generating all the numbers up to $2^{|\Delta|}$ -- where $\Delta$ is the sequent -- and using the bit representation of those to create the two subsets.
As we will see in \ref{sec:benchmarking} this implementation choice will result in a degradation of performance on formulae with a high number of multiplicatives.

Their particular usage of why-not height and implementation of the decide rule was a major influence on our own implementation and thus has been already discussed in \S\ref{chapter:implementation}.
For the sake of clarity the prover uses a fixed local bound.
This bound does not represents the number of contraction per branch, but instead the number of times the unrestricted formulae can be copied in the queue per branch.

\section{llprover}
\texttt{llprover} is a prover written in Prolog by Naoyuki Tamura.
Where APLL had different provers for intuitionistic and classical linear logic, this prover encodes all the rules as the same predicate \texttt{rule/6}, using the first argument as a selector for the system.
Choosing full classical logic as the system uses all the rules, including the ones for intuitionistic linear logic.
For this reason the prover does not use normalization; instead the option is given to transform the two-sided proof to a one-sided one.

Tensor splitting is implemented similarly to APLL by trying every possible partition
\begin{minted}[linenos]{prolog}
rule([ill,0], no,  r(*), S, [S1, S2], [r(N),r(N1),r(N2)]) :-
  match(S,  ([X]-->[Y1,[A*B],Y2])),
  merge(X1, X2, X),
  merge(Y11, Y12, Y1),
  merge(Y21, Y22, Y2),
  match(S1, ([X1]-->[Y11,[A],Y21])),
  match(S2, ([X2]-->[Y12,[B],Y22])),
  length(Y1, N), length(Y11, N1), length(Y12, N2).
\end{minted}
Here \texttt{merge/3} (lines 3, 4 and 5) -- called with the only the third argument bound -- generates all possible lists that when merged together return the original sequents.

Another particular characteristic of llprover is that it uses a local bound with iterative deepening: the prover will repeatedly try to prove the sequent, each time incrementing the bound up to the maximum specified.
This guarantees finding the simplest proof, at the expense of the overall performance.
This is unlike our prover or APLL, which instead directly use the specified bound.

