\documentclass[a4paper, 12pt, italian]{extarticle}

\usepackage[italian]{babel}
\usepackage[margin=2.5cm]{geometry}
\usepackage{setspace}

\usepackage[a-1b]{pdfx}

\begin{document}
\begin{center}
{\huge
\begin{setspace}{1.125}
\textsc{Proof Search in Propositional Linear Logic via Boolean Constraints Satisfaction}
\end{setspace}
}
\vspace{.2cm}
\textsc{Martino D'Adda -- 964827}
\vspace{.2cm}
\textsc{21 giugno 2024}
\end{center}

\section{Ente presso cui è stato svolto il lavoro di stage}
Il lavoro di tirocinio è stato di tipologia interna presso il dipartimento di Informatica dell'Università degli Studi di Milano, sotto la supervisione del docente Alberto Momigliano e il docente Camillo Fiorentini.

\section{Contesto iniziale}
Nell'ambito dei dimostratori automatici bottom-up per la logica lineare, una delle principali fonti di complessità p un'operazione chiamata splitting.
Questa richiede che ripetutamente durante la computazione della dimostrazione si necessario partizionare il multiset di formule, portando ad una esplosione combinatoria che si aggiunge all'inerente complessità del proof searching.

Il lavoro di tirocinio inizia da un articolo del 2001 di J. Harland e D. Pym \cite{HarlandPym} dove si propone un metodo alternativo per affrontare lo splitting affidandosi a vincoli booleani.
I vincoli vengono generati in modo tale che se questi sono soddisfacibili, allora la dimostrazione è corretta. 
In questo modo i multiset di formule non vengono mai effettivamente partizionati, e la complessità viene spostata dalla generazione della partizione corretta, alla ricerca di un assegnamento per i vincoli booleani.

\section{Obiettivi del lavoro}
L'obiettivo principale del lavoro è stato implementare un prover basato sul calcolo di sopra e, una volta fatto questo, valutarne la efficacia anche rispetto ad altri prover esistenti.

\section{Descrizione del lavoro svolto}
Inizialmente ̀e stato implementato un prover basato direttamente sul calcolo di \cite{HarlandPym}, ma questo si ̀e rivelato inefficiente.
Successivamente sono state applicate alcune modifiche ormai assodate nell’ambito del theorem proving quali la normalizzazione e il focusing \cite{Focusing}.
Di questo nuovo calcolo ̀e stata prima dimostrata la correttezza, esibendo una traduzione verso il calcolo triadico di \cite{Focusing}.
Infine la nuova implementazione ̀e stata confrontata con due altri prover: APLL \cite{APLL} and llprover \cite{llprover}.

\section{Tecnologie coinvolte}
Sono state coinvolte le seguenti tecnologie:
\begin{itemize}
	\item il linguaggio SWI-Prolog per la scrittura del prover, con particolare enfasi sulle sue librerie per il constraint logic programming (CLP);
	\item il linguaggio OCaML per la scrittura di un generatore di formule randomiche;
	\item il linguaggio Python e Jupyter Notebook per l’infrastruttura necessaria per comparare diversi prover;
	\item il linguaggio Nix (flake) e bash per l’automazione dei processi di compilazione e la
generazione di ambienti di sviluppo riproducibili.
\end{itemize}

\section{Competenze e risultati raggiunti}
I benchmark hanno evidenziato come l’utilizzo dei vincoli booleani, assieme al focusing e alla normalizzazione, permettano di ottenere risultati competitivi nell’ambito della logica lineare moltiplicativa.

Il lavoro di tirocinio mi ha dato l’opportunità di avvicinarmi all’ambito della dimostrazione automatica, e a familiarizzarmi con la notazione del calcolo dei sequenti.
Inoltre l’utilizzo di Prolog per l’implementazione mi ha permesso di esplorare diversi ambiti della programmazione logica, ad esempio le CFG e CLP.

Una delle problematiche principali si ̀e rivelata essere la carenza di test senza esponenziali, infatti la quasi totalità dei dataset di formule di logica lineare ̀e costituito da traduzioni di teoremi intuizionisti o di reti di Petri; entrambi casi caratterizzati da un alto numero di esponenziali.
Visto che il nostro obiettivo principale era di valutare il prover nel caso moltiplicativo, è stato necessario trovare fonti alternative di formule.
A questo scopo abbiamo implementato un generatore randomico di formule affinché generasse casi senza esponenziali.

\newpage
\bibliographystyle{plain}
\bibliography{refs}

\end{document}
